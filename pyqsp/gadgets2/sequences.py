
"""
Atomic gadgets refer to series of sequence objects; all of these are assumed to act on some subset of the b 'working qubits' of a given gadget. The SequenceObject also contains possibly empty reference to controls
"""
class SequenceObject:
    def __init__(self, target=None, controls=None):
        '''
        Represent an element of a sequence list, each of which is a gate in a quantum circuit.
        
        target: (int) 0-indexed number specifying qubit which should be acted upon by the target of the gate
        controls: (list) list of 0-indexed numbers specifying control qubits for the gate

        # TODO: controls and target are properties of a traversal of a gadget assemblage, not the basic objects; every time the depth increases during a traversal, the phases inside the main W aren't controllized, but the ones in the conjugating rotations are. Each of these contains oracles, which can have their own dual-case control procedures later down the line. At the end, bare oracles appear possibly from each input leg.
        # TODO: controls are only used, for each output leg, at the same depth.
        # TODO: what we should do is copy the contents of each object, but with an instantiated control and target.
        # TODO: For the extraction procedure, we sub in the proper x rotations and fixed phases generated by another procedure; these are always flatly generated, with controls added later.
        # TODO: The target, for each output leg, should always be the same qubit; this can be accomplished for the phase-kickbacks with SWAP objects.
        # Sequences are assigned to wires, and controls depend on when that wire was encountered in traversing the assemblage; as long as we copy objects to create the final sequence, we should be good.
        '''
        self.target = target
        self.controls = controls

class XGate(SequenceObject):
    
    def __init__(self, angle):
        self.angle = angle
        super().__init__()

    def __str__(self):
        string = "[X: %0.3f]" % self.angle
        return string

class YGate(SequenceObject):
    
    def __init__(self, angle):
        self.angle = angle
        super().__init__()

    def __str__(self):
        string = "[Y: %0.3f]" % self.angle
        return string

class ZGate(SequenceObject):
    
    def __init__(self, angle):
        self.angle = angle
        super().__init__()

    def __str__(self):
        string = "[Z: %0.3f]" % self.angle
        return string

class SignalGate(SequenceObject):
    
    def __init__(self, label):
        # This label should be an integer; check this.
        self.label = label
        super().__init__()

    def __str__(self):
        string = "[SIG: %d]" % self.label
        return string

class SwapGate(SequenceObject):
    
    def __init__(self, index_0, index_1):
        self.index_0 = index_0
        self.index_1 = index_1
        super().__init__()
    
    def __str__(self):
        string = "[SWAP: %d-%d]" % (index_0, index_1)
        return string
